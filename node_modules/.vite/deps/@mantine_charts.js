import {
  Area,
  AreaChart,
  Bar,
  BarChart,
  CartesianGrid,
  Cell,
  Label,
  Legend,
  Line,
  LineChart,
  Pie,
  PieChart,
  PolarAngleAxis,
  PolarGrid,
  PolarRadiusAxis,
  Radar,
  RadarChart,
  ReferenceLine,
  ResponsiveContainer,
  Scatter,
  ScatterChart,
  Tooltip,
  XAxis,
  YAxis,
  ZAxis
} from "./chunk-ZVW5T6LB.js";
import {
  Box,
  ColorSwatch,
  Group,
  Text,
  createVarsResolver,
  factory,
  getThemeColor,
  rem,
  require_jsx_runtime,
  useId,
  useMantineTheme,
  useProps,
  useResolvedStylesApi,
  useStyles
} from "./chunk-MRS6GTRU.js";
import "./chunk-O5ZP2HPU.js";
import "./chunk-XBHG3ID7.js";
import {
  require_react
} from "./chunk-YSDLPTTY.js";
import {
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/@mantine/charts/esm/ChartTooltip/ChartTooltip.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/charts/esm/utils/get-series-labels/get-series-labels.mjs
function getSeriesLabels(series) {
  if (!series) {
    return {};
  }
  return series.reduce((acc, item) => {
    acc[item.name] = item.label;
    return acc;
  }, {});
}

// node_modules/@mantine/charts/esm/ChartTooltip/ChartTooltip.module.css.mjs
var classes = { "tooltip": "m_e4d36c9b", "tooltipLabel": "m_7f4bcb19", "tooltipBody": "m_3de554dd", "tooltipItem": "m_3de8964e", "tooltipItemColor": "m_b30369b5", "tooltipItemBody": "m_50186d10", "tooltipItemName": "m_501dadf9", "tooltipItemData": "m_50192318" };

// node_modules/@mantine/charts/esm/ChartTooltip/ChartTooltip.mjs
function updateChartTooltipPayload(payload) {
  return payload.map((item) => {
    const newDataKey = item.name.split(".").pop();
    return {
      ...item,
      name: newDataKey
    };
  });
}
function getFilteredChartTooltipPayload(payload, segmentId) {
  const duplicatesFilter = updateChartTooltipPayload(
    payload.filter((item) => item.fill !== "none" || !item.color)
  );
  if (!segmentId) {
    return duplicatesFilter;
  }
  return duplicatesFilter.filter((item) => item.name === segmentId);
}
function getData(item, type) {
  if (type === "radial" || type === "scatter") {
    if (Array.isArray(item.value)) {
      return item.value[1] - item.value[0];
    }
    return item.value;
  }
  if (Array.isArray(item.payload[item.dataKey])) {
    return item.payload[item.dataKey][1] - item.payload[item.dataKey][0];
  }
  return item.payload[item.dataKey];
}
var defaultProps = {
  type: "area",
  showColor: true
};
var ChartTooltip = factory((_props, ref) => {
  var _a, _b;
  const props = useProps("ChartTooltip", defaultProps, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    payload,
    label,
    unit,
    type,
    segmentId,
    mod,
    series,
    valueFormatter,
    showColor,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles = useStyles({
    name: "ChartTooltip",
    classes,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled
  });
  if (!payload) {
    return null;
  }
  const filteredPayload = getFilteredChartTooltipPayload(payload, segmentId);
  const scatterLabel = type === "scatter" ? (_b = (_a = payload[0]) == null ? void 0 : _a.payload) == null ? void 0 : _b.name : null;
  const labels = getSeriesLabels(series);
  const _label = label || scatterLabel;
  const items = filteredPayload.map((item) => (0, import_jsx_runtime.jsxs)("div", { "data-type": type, ...getStyles("tooltipItem"), children: [
    (0, import_jsx_runtime.jsxs)("div", { ...getStyles("tooltipItemBody"), children: [
      showColor && (0, import_jsx_runtime.jsx)(
        ColorSwatch,
        {
          color: getThemeColor(item.color, theme),
          size: 12,
          ...getStyles("tooltipItemColor"),
          withShadow: false
        }
      ),
      (0, import_jsx_runtime.jsx)("div", { ...getStyles("tooltipItemName"), children: labels[item.name] || item.name })
    ] }),
    (0, import_jsx_runtime.jsxs)("div", { ...getStyles("tooltipItemData"), children: [
      typeof valueFormatter === "function" ? valueFormatter(getData(item, type)) : getData(item, type),
      unit || item.unit
    ] })
  ] }, (item == null ? void 0 : item.key) ?? item.name));
  return (0, import_jsx_runtime.jsxs)(Box, { ...getStyles("tooltip"), mod: [{ type }, mod], ref, ...others, children: [
    _label && (0, import_jsx_runtime.jsx)("div", { ...getStyles("tooltipLabel"), children: _label }),
    (0, import_jsx_runtime.jsx)("div", { ...getStyles("tooltipBody"), children: items })
  ] });
});
ChartTooltip.displayName = "@mantine/charts/ChartTooltip";

// node_modules/@mantine/charts/esm/ChartLegend/ChartLegend.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/charts/esm/ChartLegend/ChartLegend.module.css.mjs
var classes2 = { "legend": "m_847eaf", "legendItem": "m_17da7e62", "legendItemColor": "m_6e236e21", "legendItemName": "m_8ff56c0d" };

// node_modules/@mantine/charts/esm/ChartLegend/ChartLegend.mjs
function updateChartLegendPayload(payload) {
  return payload.map((item) => {
    const newDataKey = item.dataKey.split(".").pop();
    return {
      ...item,
      dataKey: newDataKey,
      payload: {
        ...item.payload,
        name: newDataKey,
        dataKey: newDataKey
      }
    };
  });
}
function getFilteredChartLegendPayload(payload) {
  return updateChartLegendPayload(payload.filter((item) => item.color !== "none"));
}
var defaultProps2 = {};
var ChartLegend = factory((_props, ref) => {
  const props = useProps("ChartLegend", defaultProps2, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    payload,
    onHighlight,
    legendPosition,
    mod,
    series,
    showColor,
    centered,
    ...others
  } = props;
  const getStyles = useStyles({
    name: "ChartLegend",
    classes: classes2,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled
  });
  if (!payload) {
    return null;
  }
  const filteredPayload = getFilteredChartLegendPayload(payload);
  const labels = getSeriesLabels(series);
  const items = filteredPayload.map((item, index) => (0, import_jsx_runtime2.jsxs)(
    "div",
    {
      ...getStyles("legendItem"),
      onMouseEnter: () => onHighlight(item.dataKey),
      onMouseLeave: () => onHighlight(null),
      "data-without-color": showColor === false || void 0,
      children: [
        (0, import_jsx_runtime2.jsx)(
          ColorSwatch,
          {
            color: item.color,
            size: 12,
            ...getStyles("legendItemColor"),
            withShadow: false
          }
        ),
        (0, import_jsx_runtime2.jsx)("p", { ...getStyles("legendItemName"), children: labels[item.dataKey] || item.dataKey })
      ]
    },
    index
  ));
  return (0, import_jsx_runtime2.jsx)(
    Box,
    {
      ref,
      mod: [{ position: legendPosition, centered }, mod],
      ...getStyles("legend"),
      ...others,
      children: items
    }
  );
});
ChartLegend.displayName = "@mantine/charts/ChartLegend";

// node_modules/@mantine/charts/esm/AreaChart/AreaChart.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/@mantine/charts/esm/AreaChart/AreaGradient.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
function AreaGradient({ color, id, withGradient, fillOpacity }) {
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: withGradient ? (0, import_jsx_runtime3.jsxs)("linearGradient", { id, x1: "0", y1: "0", x2: "0", y2: "1", children: [
    (0, import_jsx_runtime3.jsx)("stop", { offset: "0%", stopColor: color, stopOpacity: fillOpacity }),
    (0, import_jsx_runtime3.jsx)("stop", { offset: "100%", stopColor: color, stopOpacity: 0.01 })
  ] }) : (0, import_jsx_runtime3.jsx)("linearGradient", { id, x1: "0", y1: "0", x2: "0", y2: "1", children: (0, import_jsx_runtime3.jsx)("stop", { stopColor: color, stopOpacity: fillOpacity ?? 0.2 }) }) });
}
AreaGradient.displayName = "@mantine/charts/AreaGradient";

// node_modules/@mantine/charts/esm/AreaChart/AreaSplit.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function AreaSplit({ offset, id, colors, fillOpacity }) {
  const theme = useMantineTheme();
  return (0, import_jsx_runtime4.jsxs)("linearGradient", { id, x1: "0", y1: "0", x2: "0", y2: "1", children: [
    (0, import_jsx_runtime4.jsx)(
      "stop",
      {
        offset,
        stopColor: getThemeColor(colors[0], theme),
        stopOpacity: fillOpacity ?? 0.2
      }
    ),
    (0, import_jsx_runtime4.jsx)(
      "stop",
      {
        offset,
        stopColor: getThemeColor(colors[1], theme),
        stopOpacity: fillOpacity ?? 0.2
      }
    )
  ] });
}
AreaSplit.displayName = "@mantine/charts/AreaSplit";

// node_modules/@mantine/charts/esm/AreaChart/get-split-offset.mjs
function getSplitOffset({ data, dataKey }) {
  const dataMax = Math.max(...data.map((item) => item[dataKey]));
  const dataMin = Math.min(...data.map((item) => item[dataKey]));
  if (dataMax <= 0) {
    return 0;
  }
  if (dataMin >= 0) {
    return 1;
  }
  return dataMax / (dataMax - dataMin);
}
function getDefaultSplitOffset({ data, series }) {
  if (series.length === 1) {
    const dataKey = series[0].name;
    return getSplitOffset({ data, dataKey });
  }
  return 0.5;
}

// node_modules/@mantine/charts/esm/grid-chart.module.css.mjs
var classes3 = { "root": "m_a50f3e58", "container": "m_af9188cb", "grid": "m_a50a48bc", "axis": "m_a507a517", "axisLabel": "m_2293801d", "tooltip": "m_92b296cd" };

// node_modules/@mantine/charts/esm/AreaChart/AreaChart.mjs
function valueToPercent(value) {
  return `${(value * 100).toFixed(0)}%`;
}
var defaultProps3 = {
  withXAxis: true,
  withYAxis: true,
  withDots: true,
  withTooltip: true,
  connectNulls: true,
  strokeWidth: 2,
  tooltipAnimationDuration: 0,
  fillOpacity: 0.2,
  tickLine: "y",
  strokeDasharray: "5 5",
  curveType: "monotone",
  gridAxis: "x",
  type: "default",
  splitColors: ["green.7", "red.7"],
  orientation: "horizontal"
};
var varsResolver = createVarsResolver((theme, { textColor, gridColor }) => ({
  root: {
    "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
    "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0
  }
}));
var AreaChart2 = factory((_props, ref) => {
  const props = useProps("AreaChart", defaultProps3, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    series,
    withGradient,
    dataKey,
    withXAxis,
    withYAxis,
    curveType,
    gridProps,
    withDots,
    tickLine,
    strokeDasharray,
    gridAxis,
    unit,
    yAxisProps,
    xAxisProps,
    dotProps,
    activeDotProps,
    strokeWidth,
    tooltipAnimationDuration,
    type,
    legendProps,
    tooltipProps,
    withLegend,
    withTooltip,
    areaChartProps,
    fillOpacity,
    splitColors,
    splitOffset,
    connectNulls,
    onMouseLeave,
    orientation,
    referenceLines,
    dir,
    valueFormatter,
    children,
    areaProps,
    xAxisLabel,
    yAxisLabel,
    withRightYAxis,
    rightYAxisLabel,
    rightYAxisProps,
    ...others
  } = props;
  const theme = useMantineTheme();
  const baseId = (0, import_react.useId)();
  const splitId = `${baseId}-split`;
  const withXTickLine = gridAxis !== "none" && (tickLine === "x" || tickLine === "xy");
  const withYTickLine = gridAxis !== "none" && (tickLine === "y" || tickLine === "xy");
  const isAnimationActive = (tooltipAnimationDuration || 0) > 0;
  const _withGradient = typeof withGradient === "boolean" ? withGradient : type === "default";
  const stacked = type === "stacked" || type === "percent";
  const [highlightedArea, setHighlightedArea] = (0, import_react.useState)(null);
  const shouldHighlight = highlightedArea !== null;
  const handleMouseLeave = (event) => {
    setHighlightedArea(null);
    onMouseLeave == null ? void 0 : onMouseLeave(event);
  };
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const getStyles = useStyles({
    name: "AreaChart",
    classes: classes3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver
  });
  const dotsAreas = series.map((item) => {
    const color = getThemeColor(item.color, theme);
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    return (0, import_react.createElement)(
      Area,
      {
        ...getStyles("area"),
        activeDot: { fill: theme.white, stroke: color, strokeWidth: 2, r: 4, ...activeDotProps },
        dot: { fill: color, fillOpacity: dimmed ? 0 : 1, strokeWidth: 2, r: 4, ...dotProps },
        key: item.name,
        name: item.name,
        type: curveType,
        dataKey: item.name,
        fill: "none",
        strokeWidth,
        stroke: "none",
        isAnimationActive: false,
        connectNulls,
        stackId: stacked ? "stack-dots" : void 0,
        yAxisId: item.yAxisId || "left",
        ...typeof areaProps === "function" ? areaProps(item) : areaProps
      }
    );
  });
  const areas = series.map((item) => {
    const id = `${baseId}-${item.color.replace(/[^a-zA-Z0-9]/g, "")}`;
    const color = getThemeColor(item.color, theme);
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    return (0, import_jsx_runtime5.jsxs)(import_react.Fragment, { children: [
      (0, import_jsx_runtime5.jsx)("defs", { children: (0, import_jsx_runtime5.jsx)(
        AreaGradient,
        {
          color,
          withGradient: _withGradient,
          id,
          fillOpacity
        }
      ) }),
      (0, import_jsx_runtime5.jsx)(
        Area,
        {
          ...getStyles("area"),
          activeDot: false,
          dot: false,
          name: item.name,
          type: curveType,
          dataKey: item.name,
          fill: type === "split" ? `url(#${splitId})` : `url(#${id})`,
          strokeWidth,
          stroke: color,
          isAnimationActive: false,
          connectNulls,
          stackId: stacked ? "stack" : void 0,
          fillOpacity: dimmed ? 0 : 1,
          strokeOpacity: dimmed ? 0.5 : 1,
          strokeDasharray: item.strokeDasharray,
          yAxisId: item.yAxisId || "left",
          ...typeof areaProps === "function" ? areaProps(item) : areaProps
        }
      )
    ] }, item.name);
  });
  const referenceLinesItems = referenceLines == null ? void 0 : referenceLines.map((line, index) => {
    const color = getThemeColor(line.color, theme);
    return (0, import_jsx_runtime5.jsx)(
      ReferenceLine,
      {
        stroke: line.color ? color : "var(--chart-grid-color)",
        strokeWidth: 1,
        yAxisId: line.yAxisId || "left",
        ...line,
        label: {
          value: line.label,
          fill: line.color ? color : "currentColor",
          fontSize: 12,
          position: line.labelPosition ?? "insideBottomLeft"
        },
        ...getStyles("referenceLine")
      },
      index
    );
  });
  const sharedYAxisProps = {
    axisLine: false,
    ...orientation === "vertical" ? { dataKey, type: "category" } : { type: "number" },
    tickLine: withYTickLine ? { stroke: "currentColor" } : false,
    allowDecimals: true,
    unit,
    tickFormatter: type === "percent" ? valueToPercent : valueFormatter,
    ...getStyles("axis")
  };
  return (0, import_jsx_runtime5.jsx)(
    Box,
    {
      ref,
      ...getStyles("root"),
      onMouseLeave: handleMouseLeave,
      dir: dir || "ltr",
      ...others,
      children: (0, import_jsx_runtime5.jsx)(ResponsiveContainer, { ...getStyles("container"), children: (0, import_jsx_runtime5.jsxs)(
        AreaChart,
        {
          data,
          stackOffset: type === "percent" ? "expand" : void 0,
          layout: orientation,
          margin: {
            bottom: xAxisLabel ? 30 : void 0,
            left: yAxisLabel ? 10 : void 0,
            right: yAxisLabel ? 5 : void 0
          },
          ...areaChartProps,
          children: [
            referenceLinesItems,
            withLegend && (0, import_jsx_runtime5.jsx)(
              Legend,
              {
                verticalAlign: "top",
                content: (payload) => (0, import_jsx_runtime5.jsx)(
                  ChartLegend,
                  {
                    payload: payload.payload,
                    onHighlight: setHighlightedArea,
                    legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "top",
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series
                  }
                ),
                ...legendProps
              }
            ),
            (0, import_jsx_runtime5.jsx)(
              CartesianGrid,
              {
                strokeDasharray,
                vertical: gridAxis === "y" || gridAxis === "xy",
                horizontal: gridAxis === "x" || gridAxis === "xy",
                ...getStyles("grid"),
                ...gridProps
              }
            ),
            (0, import_jsx_runtime5.jsxs)(
              XAxis,
              {
                hide: !withXAxis,
                ...orientation === "vertical" ? { type: "number" } : { dataKey },
                tick: { transform: "translate(0, 10)", fontSize: 12, fill: "currentColor" },
                stroke: "",
                interval: "preserveStartEnd",
                tickLine: withXTickLine ? { stroke: "currentColor" } : false,
                minTickGap: 5,
                ...getStyles("axis"),
                ...xAxisProps,
                children: [
                  xAxisLabel && (0, import_jsx_runtime5.jsx)(Label, { position: "insideBottom", offset: -20, fontSize: 12, ...getStyles("axisLabel"), children: xAxisLabel }),
                  xAxisProps == null ? void 0 : xAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime5.jsxs)(
              YAxis,
              {
                yAxisId: "left",
                orientation: "left",
                tick: { transform: "translate(-10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withYAxis,
                ...sharedYAxisProps,
                ...yAxisProps,
                children: [
                  yAxisLabel && (0, import_jsx_runtime5.jsx)(
                    Label,
                    {
                      position: "insideLeft",
                      angle: -90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: yAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime5.jsxs)(
              YAxis,
              {
                yAxisId: "right",
                orientation: "right",
                tick: { transform: "translate(10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withRightYAxis,
                ...sharedYAxisProps,
                ...rightYAxisProps,
                children: [
                  rightYAxisLabel && (0, import_jsx_runtime5.jsx)(
                    Label,
                    {
                      position: "insideRight",
                      angle: 90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: rightYAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            withTooltip && (0, import_jsx_runtime5.jsx)(
              Tooltip,
              {
                animationDuration: tooltipAnimationDuration,
                isAnimationActive,
                position: orientation === "vertical" ? {} : { y: 0 },
                cursor: {
                  stroke: "var(--chart-grid-color)",
                  strokeWidth: 1,
                  strokeDasharray
                },
                content: ({ label, payload }) => (0, import_jsx_runtime5.jsx)(
                  ChartTooltip,
                  {
                    label,
                    payload,
                    unit,
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series,
                    valueFormatter
                  }
                ),
                ...tooltipProps
              }
            ),
            type === "split" && (0, import_jsx_runtime5.jsx)("defs", { children: (0, import_jsx_runtime5.jsx)(
              AreaSplit,
              {
                colors: splitColors,
                id: splitId,
                offset: splitOffset ?? getDefaultSplitOffset({ data, series }),
                fillOpacity
              }
            ) }),
            areas,
            withDots && dotsAreas,
            children
          ]
        }
      ) })
    }
  );
});
AreaChart2.classes = classes3;
AreaChart2.displayName = "@mantine/charts/AreaChart";

// node_modules/@mantine/charts/esm/BarChart/BarChart.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
function valueToPercent2(value) {
  return `${(value * 100).toFixed(0)}%`;
}
var defaultProps4 = {
  withXAxis: true,
  withYAxis: true,
  withTooltip: true,
  tooltipAnimationDuration: 0,
  fillOpacity: 1,
  tickLine: "y",
  strokeDasharray: "5 5",
  gridAxis: "x",
  type: "default"
};
var varsResolver2 = createVarsResolver(
  (theme, { textColor, gridColor, cursorFill }) => ({
    root: {
      "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
      "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0,
      "--chart-cursor-fill": cursorFill ? getThemeColor(cursorFill, theme) : void 0
    }
  })
);
function BarLabel({ value, valueFormatter, ...others }) {
  return (0, import_jsx_runtime6.jsx)(
    "text",
    {
      ...others,
      dy: -10,
      fontSize: 12,
      fill: "var(--chart-text-color, var(--mantine-color-dimmed))",
      textAnchor: "center",
      children: typeof valueFormatter === "function" ? valueFormatter(value) : value
    }
  );
}
function calculateCumulativeTotal(waterfallData, dataKey) {
  let start = 0;
  let end = 0;
  return waterfallData.map((item) => {
    if (item.standalone) {
      for (const prop in item) {
        if (typeof item[prop] === "number" && prop !== dataKey) {
          item[prop] = [0, item[prop]];
        }
      }
    } else {
      for (const prop in item) {
        if (typeof item[prop] === "number" && prop !== dataKey) {
          end += item[prop];
          item[prop] = [start, end];
          start = end;
        }
      }
    }
    return item;
  });
}
var BarChart2 = factory((_props, ref) => {
  const props = useProps("BarChart", defaultProps4, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withLegend,
    legendProps,
    series,
    onMouseLeave,
    dataKey,
    withTooltip,
    withXAxis,
    withYAxis,
    gridAxis,
    tickLine,
    xAxisProps,
    yAxisProps,
    unit,
    tooltipAnimationDuration,
    strokeDasharray,
    gridProps,
    tooltipProps,
    referenceLines,
    fillOpacity,
    barChartProps,
    type,
    orientation,
    dir,
    valueFormatter,
    children,
    barProps,
    xAxisLabel,
    yAxisLabel,
    withBarValueLabel,
    withRightYAxis,
    rightYAxisLabel,
    rightYAxisProps,
    ...others
  } = props;
  const theme = useMantineTheme();
  const withXTickLine = gridAxis !== "none" && (tickLine === "x" || tickLine === "xy");
  const withYTickLine = gridAxis !== "none" && (tickLine === "y" || tickLine === "xy");
  const [highlightedArea, setHighlightedArea] = (0, import_react2.useState)(null);
  const shouldHighlight = highlightedArea !== null;
  const stacked = type === "stacked" || type === "percent";
  const handleMouseLeave = (event) => {
    setHighlightedArea(null);
    onMouseLeave == null ? void 0 : onMouseLeave(event);
  };
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const inputData = type === "waterfall" ? calculateCumulativeTotal(data, dataKey) : data;
  const getStyles = useStyles({
    name: "BarChart",
    classes: classes3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver2
  });
  const bars = series.map((item) => {
    const color = getThemeColor(item.color, theme);
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    return (0, import_react2.createElement)(
      Bar,
      {
        ...getStyles("bar"),
        key: item.name,
        name: item.name,
        dataKey: item.name,
        fill: color,
        stroke: color,
        isAnimationActive: false,
        fillOpacity: dimmed ? 0.1 : fillOpacity,
        strokeOpacity: dimmed ? 0.2 : 0,
        stackId: stacked ? "stack" : void 0,
        label: withBarValueLabel ? (0, import_jsx_runtime6.jsx)(BarLabel, { valueFormatter }) : void 0,
        yAxisId: item.yAxisId || "left",
        ...typeof barProps === "function" ? barProps(item) : barProps
      },
      inputData.map((entry, index) => (0, import_jsx_runtime6.jsx)(
        Cell,
        {
          fill: entry.color ? getThemeColor(entry.color, theme) : color
        },
        `cell-${index}`
      ))
    );
  });
  const referenceLinesItems = referenceLines == null ? void 0 : referenceLines.map((line, index) => {
    const color = getThemeColor(line.color, theme);
    return (0, import_jsx_runtime6.jsx)(
      ReferenceLine,
      {
        stroke: line.color ? color : "var(--chart-grid-color)",
        strokeWidth: 1,
        yAxisId: line.yAxisId || "left",
        ...line,
        label: {
          value: line.label,
          fill: line.color ? color : "currentColor",
          fontSize: 12,
          position: line.labelPosition ?? "insideBottomLeft"
        },
        ...getStyles("referenceLine")
      },
      index
    );
  });
  const sharedYAxisProps = {
    axisLine: false,
    ...orientation === "vertical" ? { dataKey, type: "category" } : { type: "number" },
    tickLine: withYTickLine ? { stroke: "currentColor" } : false,
    allowDecimals: true,
    unit,
    tickFormatter: type === "percent" ? valueToPercent2 : valueFormatter,
    ...getStyles("axis")
  };
  return (0, import_jsx_runtime6.jsx)(
    Box,
    {
      ref,
      ...getStyles("root"),
      onMouseLeave: handleMouseLeave,
      dir: dir || "ltr",
      ...others,
      children: (0, import_jsx_runtime6.jsx)(ResponsiveContainer, { ...getStyles("container"), children: (0, import_jsx_runtime6.jsxs)(
        BarChart,
        {
          data: inputData,
          stackOffset: type === "percent" ? "expand" : void 0,
          layout: orientation,
          margin: {
            bottom: xAxisLabel ? 30 : void 0,
            left: yAxisLabel ? 10 : void 0,
            right: yAxisLabel ? 5 : void 0
          },
          ...barChartProps,
          children: [
            withLegend && (0, import_jsx_runtime6.jsx)(
              Legend,
              {
                verticalAlign: "top",
                content: (payload) => (0, import_jsx_runtime6.jsx)(
                  ChartLegend,
                  {
                    payload: payload.payload,
                    onHighlight: setHighlightedArea,
                    legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "top",
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series,
                    showColor: type !== "waterfall"
                  }
                ),
                ...legendProps
              }
            ),
            (0, import_jsx_runtime6.jsxs)(
              XAxis,
              {
                hide: !withXAxis,
                ...orientation === "vertical" ? { type: "number" } : { dataKey },
                tick: { transform: "translate(0, 10)", fontSize: 12, fill: "currentColor" },
                stroke: "",
                interval: "preserveStartEnd",
                tickLine: withXTickLine ? { stroke: "currentColor" } : false,
                minTickGap: 5,
                ...getStyles("axis"),
                ...xAxisProps,
                children: [
                  xAxisLabel && (0, import_jsx_runtime6.jsx)(Label, { position: "insideBottom", offset: -20, fontSize: 12, ...getStyles("axisLabel"), children: xAxisLabel }),
                  xAxisProps == null ? void 0 : xAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime6.jsxs)(
              YAxis,
              {
                yAxisId: "left",
                orientation: "left",
                tick: { transform: "translate(-10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withYAxis,
                ...sharedYAxisProps,
                ...yAxisProps,
                children: [
                  yAxisLabel && (0, import_jsx_runtime6.jsx)(
                    Label,
                    {
                      position: "insideLeft",
                      angle: -90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: yAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime6.jsxs)(
              YAxis,
              {
                yAxisId: "right",
                orientation: "right",
                tick: { transform: "translate(10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withRightYAxis,
                ...sharedYAxisProps,
                ...rightYAxisProps,
                children: [
                  rightYAxisLabel && (0, import_jsx_runtime6.jsx)(
                    Label,
                    {
                      position: "insideRight",
                      angle: 90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: rightYAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime6.jsx)(
              CartesianGrid,
              {
                strokeDasharray,
                vertical: gridAxis === "y" || gridAxis === "xy",
                horizontal: gridAxis === "x" || gridAxis === "xy",
                ...getStyles("grid"),
                ...gridProps
              }
            ),
            withTooltip && (0, import_jsx_runtime6.jsx)(
              Tooltip,
              {
                animationDuration: tooltipAnimationDuration,
                isAnimationActive: tooltipAnimationDuration !== 0,
                position: orientation === "vertical" ? {} : { y: 0 },
                cursor: {
                  stroke: "var(--chart-grid-color)",
                  strokeWidth: 1,
                  strokeDasharray,
                  fill: "var(--chart-cursor-fill)"
                },
                content: ({ label, payload }) => (0, import_jsx_runtime6.jsx)(
                  ChartTooltip,
                  {
                    label,
                    payload,
                    type: type === "waterfall" ? "scatter" : void 0,
                    unit,
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series,
                    valueFormatter
                  }
                ),
                ...tooltipProps
              }
            ),
            bars,
            referenceLinesItems,
            children
          ]
        }
      ) })
    }
  );
});
BarChart2.displayName = "@mantine/charts/BarChart";
BarChart2.classes = classes3;

// node_modules/@mantine/charts/esm/LineChart/LineChart.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var defaultProps5 = {
  withXAxis: true,
  withYAxis: true,
  withTooltip: true,
  tooltipAnimationDuration: 0,
  fillOpacity: 1,
  tickLine: "y",
  strokeDasharray: "5 5",
  gridAxis: "x",
  withDots: true,
  connectNulls: true,
  strokeWidth: 2,
  curveType: "monotone",
  gradientStops: [
    { offset: 0, color: "red" },
    { offset: 100, color: "blue" }
  ]
};
var varsResolver3 = createVarsResolver((theme, { textColor, gridColor }) => ({
  root: {
    "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
    "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0
  }
}));
var LineChart2 = factory((_props, ref) => {
  const props = useProps("LineChart", defaultProps5, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withLegend,
    legendProps,
    series,
    onMouseLeave,
    dataKey,
    withTooltip,
    withXAxis,
    withYAxis,
    gridAxis,
    tickLine,
    xAxisProps,
    yAxisProps,
    unit,
    tooltipAnimationDuration,
    strokeDasharray,
    gridProps,
    tooltipProps,
    referenceLines,
    withDots,
    dotProps,
    activeDotProps,
    strokeWidth,
    lineChartProps,
    connectNulls,
    fillOpacity,
    curveType,
    orientation,
    dir,
    valueFormatter,
    children,
    lineProps,
    xAxisLabel,
    yAxisLabel,
    type,
    gradientStops,
    withRightYAxis,
    rightYAxisLabel,
    rightYAxisProps,
    ...others
  } = props;
  const theme = useMantineTheme();
  const withXTickLine = gridAxis !== "none" && (tickLine === "x" || tickLine === "xy");
  const withYTickLine = gridAxis !== "none" && (tickLine === "y" || tickLine === "xy");
  const [highlightedArea, setHighlightedArea] = (0, import_react3.useState)(null);
  const shouldHighlight = highlightedArea !== null;
  const handleMouseLeave = (event) => {
    setHighlightedArea(null);
    onMouseLeave == null ? void 0 : onMouseLeave(event);
  };
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const getStyles = useStyles({
    name: "LineChart",
    classes: classes3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver3
  });
  const id = useId();
  const gradientId = `line-chart-gradient-${id}`;
  const stops = gradientStops == null ? void 0 : gradientStops.map((stop) => (0, import_jsx_runtime7.jsx)(
    "stop",
    {
      offset: `${stop.offset}%`,
      stopColor: getThemeColor(stop.color, theme)
    },
    stop.color
  ));
  const lines = series.map((item) => {
    const color = getThemeColor(item.color, theme);
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    return (0, import_react3.createElement)(
      Line,
      {
        ...getStyles("line"),
        key: item.name,
        name: item.name,
        dataKey: item.name,
        dot: withDots ? {
          fillOpacity: dimmed ? 0 : 1,
          strokeOpacity: dimmed ? 0 : 1,
          strokeWidth: 1,
          fill: type === "gradient" ? "var(--mantine-color-gray-7)" : color,
          stroke: type === "gradient" ? "white" : color,
          ...dotProps
        } : false,
        activeDot: withDots ? {
          fill: type === "gradient" ? "var(--mantine-color-gray-7)" : color,
          stroke: type === "gradient" ? "white" : color,
          ...activeDotProps
        } : false,
        fill: color,
        stroke: type === "gradient" ? `url(#${gradientId})` : color,
        strokeWidth,
        isAnimationActive: false,
        fillOpacity: dimmed ? 0 : fillOpacity,
        strokeOpacity: dimmed ? 0.5 : fillOpacity,
        connectNulls,
        type: curveType,
        strokeDasharray: item.strokeDasharray,
        yAxisId: item.yAxisId || "left",
        ...typeof lineProps === "function" ? lineProps(item) : lineProps
      }
    );
  });
  const referenceLinesItems = referenceLines == null ? void 0 : referenceLines.map((line, index) => {
    const color = getThemeColor(line.color, theme);
    return (0, import_jsx_runtime7.jsx)(
      ReferenceLine,
      {
        stroke: line.color ? color : "var(--chart-grid-color)",
        strokeWidth: 1,
        yAxisId: line.yAxisId || "left",
        ...line,
        label: {
          value: line.label,
          fill: line.color ? color : "currentColor",
          fontSize: 12,
          position: line.labelPosition ?? "insideBottomLeft"
        },
        ...getStyles("referenceLine")
      },
      index
    );
  });
  const sharedYAxisProps = {
    axisLine: false,
    ...orientation === "vertical" ? { dataKey, type: "category" } : { type: "number" },
    tickLine: withYTickLine ? { stroke: "currentColor" } : false,
    allowDecimals: true,
    unit,
    tickFormatter: valueFormatter,
    ...getStyles("axis")
  };
  return (0, import_jsx_runtime7.jsx)(
    Box,
    {
      ref,
      ...getStyles("root"),
      onMouseLeave: handleMouseLeave,
      dir: dir || "ltr",
      ...others,
      children: (0, import_jsx_runtime7.jsx)(ResponsiveContainer, { ...getStyles("container"), children: (0, import_jsx_runtime7.jsxs)(
        LineChart,
        {
          data,
          layout: orientation,
          margin: {
            bottom: xAxisLabel ? 30 : void 0,
            left: yAxisLabel ? 10 : void 0,
            right: yAxisLabel ? 5 : void 0
          },
          ...lineChartProps,
          children: [
            type === "gradient" && (0, import_jsx_runtime7.jsx)("defs", { children: (0, import_jsx_runtime7.jsx)("linearGradient", { id: gradientId, x1: "0", y1: "0", x2: "0", y2: "1", children: stops }) }),
            withLegend && (0, import_jsx_runtime7.jsx)(
              Legend,
              {
                verticalAlign: "top",
                content: (payload) => (0, import_jsx_runtime7.jsx)(
                  ChartLegend,
                  {
                    payload: payload.payload,
                    onHighlight: setHighlightedArea,
                    legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "top",
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series,
                    showColor: type !== "gradient"
                  }
                ),
                ...legendProps
              }
            ),
            (0, import_jsx_runtime7.jsxs)(
              XAxis,
              {
                hide: !withXAxis,
                ...orientation === "vertical" ? { type: "number" } : { dataKey },
                tick: { transform: "translate(0, 10)", fontSize: 12, fill: "currentColor" },
                stroke: "",
                interval: "preserveStartEnd",
                tickLine: withXTickLine ? { stroke: "currentColor" } : false,
                minTickGap: 5,
                ...getStyles("axis"),
                ...xAxisProps,
                children: [
                  xAxisLabel && (0, import_jsx_runtime7.jsx)(Label, { position: "insideBottom", offset: -20, fontSize: 12, ...getStyles("axisLabel"), children: xAxisLabel }),
                  xAxisProps == null ? void 0 : xAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime7.jsxs)(
              YAxis,
              {
                yAxisId: "left",
                orientation: "left",
                tick: { transform: "translate(-10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withYAxis,
                ...sharedYAxisProps,
                ...yAxisProps,
                children: [
                  yAxisLabel && (0, import_jsx_runtime7.jsx)(
                    Label,
                    {
                      position: "insideLeft",
                      angle: -90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: yAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime7.jsxs)(
              YAxis,
              {
                yAxisId: "right",
                orientation: "right",
                tick: { transform: "translate(10, 0)", fontSize: 12, fill: "currentColor" },
                hide: !withRightYAxis,
                ...sharedYAxisProps,
                ...rightYAxisProps,
                children: [
                  rightYAxisLabel && (0, import_jsx_runtime7.jsx)(
                    Label,
                    {
                      position: "insideRight",
                      angle: 90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: rightYAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime7.jsx)(
              CartesianGrid,
              {
                strokeDasharray,
                vertical: gridAxis === "y" || gridAxis === "xy",
                horizontal: gridAxis === "x" || gridAxis === "xy",
                ...getStyles("grid"),
                ...gridProps
              }
            ),
            withTooltip && (0, import_jsx_runtime7.jsx)(
              Tooltip,
              {
                animationDuration: tooltipAnimationDuration,
                isAnimationActive: tooltipAnimationDuration !== 0,
                position: orientation === "vertical" ? {} : { y: 0 },
                cursor: {
                  stroke: "var(--chart-grid-color)",
                  strokeWidth: 1,
                  strokeDasharray
                },
                content: ({ label, payload }) => (0, import_jsx_runtime7.jsx)(
                  ChartTooltip,
                  {
                    label,
                    payload,
                    unit,
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series,
                    valueFormatter,
                    showColor: type !== "gradient"
                  }
                ),
                ...tooltipProps
              }
            ),
            lines,
            referenceLinesItems,
            children
          ]
        }
      ) })
    }
  );
});
LineChart2.displayName = "@mantine/charts/LineChart";
LineChart2.classes = classes3;

// node_modules/@mantine/charts/esm/Sparkline/Sparkline.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var classes4 = {};
var defaultProps6 = {
  withGradient: true,
  connectNulls: true,
  fillOpacity: 0.6,
  strokeWidth: 2,
  curveType: "linear"
};
function getTrendColor(data, trendColors) {
  const first = data[0];
  const last = data[data.length - 1];
  if (first === null || last === null) {
    return trendColors.neutral || trendColors.positive;
  }
  if (first < last) {
    return trendColors.positive;
  }
  if (first > last) {
    return trendColors.negative;
  }
  return trendColors.neutral || trendColors.positive;
}
var varsResolver4 = createVarsResolver(
  (theme, { color, data, trendColors }) => ({
    root: {
      "--chart-color": trendColors ? getThemeColor(getTrendColor(data, trendColors), theme) : color ? getThemeColor(color, theme) : void 0
    }
  })
);
var Sparkline = factory((_props, ref) => {
  const props = useProps("Sparkline", defaultProps6, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withGradient,
    fillOpacity,
    curveType,
    strokeWidth,
    trendColors,
    connectNulls,
    areaProps,
    ...others
  } = props;
  const getStyles = useStyles({
    name: "Sparkline",
    classes: classes4,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver4
  });
  const id = (0, import_react4.useId)();
  const mappedData = (0, import_react4.useMemo)(() => data.map((value, index) => ({ value, index })), [data]);
  return (0, import_jsx_runtime8.jsx)(Box, { ref, ...getStyles("root"), ...others, dir: "ltr", children: (0, import_jsx_runtime8.jsx)(ResponsiveContainer, { children: (0, import_jsx_runtime8.jsxs)(AreaChart, { data: mappedData, children: [
    (0, import_jsx_runtime8.jsx)(
      Area,
      {
        dataKey: "value",
        type: curveType,
        fill: `url(#${id})`,
        stroke: "var(--chart-color, var(--mantine-color-blue-filled))",
        isAnimationActive: false,
        connectNulls,
        strokeWidth,
        fillOpacity: 1,
        ...areaProps
      }
    ),
    (0, import_jsx_runtime8.jsx)("defs", { children: (0, import_jsx_runtime8.jsx)(
      AreaGradient,
      {
        id,
        color: "var(--chart-color, var(--mantine-color-blue-filled))",
        fillOpacity,
        withGradient
      }
    ) })
  ] }) }) });
});
Sparkline.displayName = "@mantine/charts/Sparkline";
Sparkline.classes = classes4;

// node_modules/@mantine/charts/esm/DonutChart/DonutChart.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/charts/esm/DonutChart/DonutChart.module.css.mjs
var classes5 = { "root": "m_a410e613", "label": "m_ddb0bfe3" };

// node_modules/@mantine/charts/esm/DonutChart/DonutChart.mjs
var defaultProps7 = {
  withTooltip: true,
  withLabelsLine: true,
  paddingAngle: 0,
  thickness: 20,
  size: 160,
  strokeWidth: 1,
  startAngle: 0,
  endAngle: 360,
  tooltipDataSource: "all"
};
var varsResolver5 = createVarsResolver(
  (theme, { strokeColor, labelColor, withLabels, size }) => ({
    root: {
      "--chart-stroke-color": strokeColor ? getThemeColor(strokeColor, theme) : void 0,
      "--chart-labels-color": labelColor ? getThemeColor(labelColor, theme) : void 0,
      "--chart-size": withLabels ? rem(size + 80) : rem(size)
    }
  })
);
var DonutChart = factory((_props, ref) => {
  const props = useProps("DonutChart", defaultProps7, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withTooltip,
    tooltipAnimationDuration,
    tooltipProps,
    pieProps,
    paddingAngle,
    withLabels,
    withLabelsLine,
    size,
    thickness,
    strokeWidth,
    startAngle,
    endAngle,
    tooltipDataSource,
    chartLabel,
    children,
    pieChartProps,
    valueFormatter,
    strokeColor,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles = useStyles({
    name: "DonutChart",
    classes: classes5,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver5
  });
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const cells = data.map((item, index) => (0, import_jsx_runtime9.jsx)(
    Cell,
    {
      fill: getThemeColor(item.color, theme),
      stroke: "var(--chart-stroke-color, var(--mantine-color-body))",
      strokeWidth
    },
    index
  ));
  return (0, import_jsx_runtime9.jsx)(Box, { ref, size, ...getStyles("root"), ...others, children: (0, import_jsx_runtime9.jsx)(ResponsiveContainer, { children: (0, import_jsx_runtime9.jsxs)(PieChart, { ...pieChartProps, children: [
    (0, import_jsx_runtime9.jsx)(
      Pie,
      {
        data,
        innerRadius: size / 2 - thickness,
        outerRadius: size / 2,
        dataKey: "value",
        isAnimationActive: false,
        paddingAngle,
        startAngle,
        endAngle,
        label: withLabels ? {
          fill: "var(--chart-labels-color, var(--mantine-color-dimmed))",
          fontSize: 12,
          fontFamily: "var(--mantine-font-family)"
        } : false,
        labelLine: withLabelsLine ? {
          stroke: "var(--chart-label-color, var(--mantine-color-dimmed))",
          strokeWidth: 1
        } : false,
        ...pieProps,
        children: cells
      }
    ),
    chartLabel && (0, import_jsx_runtime9.jsx)(
      "text",
      {
        x: "50%",
        y: "50%",
        textAnchor: "middle",
        dominantBaseline: "middle",
        ...getStyles("label"),
        children: chartLabel
      }
    ),
    withTooltip && (0, import_jsx_runtime9.jsx)(
      Tooltip,
      {
        animationDuration: tooltipAnimationDuration,
        isAnimationActive: false,
        content: ({ payload }) => {
          var _a;
          return (0, import_jsx_runtime9.jsx)(
            ChartTooltip,
            {
              payload: data,
              classNames: resolvedClassNames,
              styles: resolvedStyles,
              type: "radial",
              segmentId: tooltipDataSource === "segment" ? (_a = payload == null ? void 0 : payload[0]) == null ? void 0 : _a.name : void 0,
              valueFormatter
            }
          );
        },
        ...tooltipProps
      }
    ),
    children
  ] }) }) });
});
DonutChart.displayName = "@mantine/charts/DonutChart";
DonutChart.classes = classes5;

// node_modules/@mantine/charts/esm/PieChart/PieChart.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);

// node_modules/@mantine/charts/esm/PieChart/PieChart.module.css.mjs
var classes6 = { "root": "m_cd8943fd", "label": "m_e3441f39" };

// node_modules/@mantine/charts/esm/PieChart/PieChart.mjs
var defaultProps8 = {
  withTooltip: false,
  withLabelsLine: true,
  paddingAngle: 0,
  size: 160,
  strokeWidth: 1,
  startAngle: 0,
  endAngle: 360,
  tooltipDataSource: "all",
  labelsPosition: "outside",
  labelsType: "value"
};
var varsResolver6 = createVarsResolver(
  (theme, { strokeColor, labelColor, withLabels, size, labelsPosition }) => ({
    root: {
      "--chart-stroke-color": strokeColor ? getThemeColor(strokeColor, theme) : void 0,
      "--chart-labels-color": labelColor ? getThemeColor(labelColor, theme) : void 0,
      "--chart-size": withLabels && labelsPosition === "outside" ? rem(size + 80) : rem(size)
    }
  })
);
var getInsideLabel = (labelsType, valueFormatter) => ({ cx, cy, midAngle, innerRadius, outerRadius, value, percent }) => {
  const RADIAN = Math.PI / 180;
  const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
  const x = cx + radius * Math.cos(-midAngle * RADIAN);
  const y = cy + radius * Math.sin(-midAngle * RADIAN);
  return (0, import_jsx_runtime10.jsx)(
    "text",
    {
      x,
      y,
      textAnchor: x > cx ? "start" : "end",
      dominantBaseline: "central",
      className: classes6.label,
      children: labelsType === "percent" ? `${(percent * 100).toFixed(0)}%` : typeof valueFormatter === "function" ? valueFormatter(value) : value
    }
  );
};
var PieChart2 = factory((_props, ref) => {
  const props = useProps("PieChart", defaultProps8, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    withTooltip,
    tooltipAnimationDuration,
    tooltipProps,
    pieProps,
    paddingAngle,
    withLabels,
    withLabelsLine,
    size,
    strokeWidth,
    startAngle,
    endAngle,
    tooltipDataSource,
    children,
    pieChartProps,
    labelsPosition,
    valueFormatter,
    labelsType,
    strokeColor,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles = useStyles({
    name: "PieChart",
    classes: classes6,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver6
  });
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const cells = data.map((item, index) => (0, import_jsx_runtime10.jsx)(
    Cell,
    {
      fill: getThemeColor(item.color, theme),
      stroke: "var(--chart-stroke-color, var(--mantine-color-body))",
      strokeWidth
    },
    index
  ));
  return (0, import_jsx_runtime10.jsx)(Box, { ref, size, ...getStyles("root"), ...others, children: (0, import_jsx_runtime10.jsx)(ResponsiveContainer, { children: (0, import_jsx_runtime10.jsxs)(PieChart, { ...pieChartProps, children: [
    (0, import_jsx_runtime10.jsx)(
      Pie,
      {
        data,
        innerRadius: 0,
        outerRadius: size / 2,
        dataKey: "value",
        isAnimationActive: false,
        paddingAngle,
        startAngle,
        endAngle,
        label: withLabels ? labelsPosition === "inside" ? getInsideLabel(labelsType || "value", valueFormatter) : labelsType === "percent" ? ({ percent, x, y, cx, cy }) => (0, import_jsx_runtime10.jsx)(
          "text",
          {
            x,
            y,
            cx,
            cy,
            textAnchor: x > cx ? "start" : "end",
            dominantBaseline: "central",
            fill: "var(--chart-labels-color, var(--mantine-color-dimmed))",
            fontFamily: "var(--mantine-font-family)",
            fontSize: 12,
            children: (0, import_jsx_runtime10.jsx)("tspan", { x, children: `${(percent * 100).toFixed(0)}%` })
          }
        ) : {
          fill: "var(--chart-labels-color, var(--mantine-color-dimmed))",
          fontSize: 12,
          fontFamily: "var(--mantine-font-family)"
        } : false,
        labelLine: withLabelsLine && labelsPosition === "outside" ? {
          stroke: "var(--chart-label-color, var(--mantine-color-dimmed))",
          strokeWidth: 1
        } : false,
        ...pieProps,
        children: cells
      }
    ),
    withTooltip && (0, import_jsx_runtime10.jsx)(
      Tooltip,
      {
        animationDuration: tooltipAnimationDuration,
        isAnimationActive: false,
        content: ({ payload }) => {
          var _a;
          return (0, import_jsx_runtime10.jsx)(
            ChartTooltip,
            {
              payload: data,
              classNames: resolvedClassNames,
              styles: resolvedStyles,
              type: "radial",
              segmentId: tooltipDataSource === "segment" ? (_a = payload == null ? void 0 : payload[0]) == null ? void 0 : _a.name : void 0,
              valueFormatter
            }
          );
        },
        ...tooltipProps
      }
    ),
    children
  ] }) }) });
});
PieChart2.displayName = "@mantine/charts/PieChart";
PieChart2.classes = classes6;

// node_modules/@mantine/charts/esm/RadarChart/RadarChart.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);

// node_modules/@mantine/charts/esm/RadarChart/RadarChart.module.css.mjs
var classes7 = { "root": "m_1f271cf7", "container": "m_cf06f58c" };

// node_modules/@mantine/charts/esm/RadarChart/RadarChart.mjs
var defaultProps9 = {
  withPolarGrid: true,
  withPolarAngleAxis: true,
  withPolarRadiusAxis: false
};
var varsResolver7 = createVarsResolver((theme, { gridColor, textColor }) => ({
  root: {
    "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0,
    "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0
  }
}));
var RadarChart2 = factory((_props, ref) => {
  const props = useProps("RadarChart", defaultProps9, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    series,
    dataKey,
    gridColor,
    textColor,
    radarProps,
    radarChartProps,
    polarGridProps,
    polarAngleAxisProps,
    polarRadiusAxisProps,
    withPolarGrid,
    withPolarAngleAxis,
    withPolarRadiusAxis,
    children,
    withLegend,
    legendProps,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles = useStyles({
    name: "RadarChart",
    classes: classes7,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver7
  });
  const [highlightedArea, setHighlightedArea] = (0, import_react5.useState)(null);
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const radars = series.map((item, index) => (0, import_jsx_runtime11.jsx)(
    Radar,
    {
      name: item.name,
      dataKey: item.name,
      stroke: getThemeColor(item.strokeColor || item.color, theme),
      fill: getThemeColor(item.color, theme),
      fillOpacity: highlightedArea ? highlightedArea === item.name ? item.opacity || 0.4 : 0.05 : item.opacity || 0.4,
      strokeOpacity: highlightedArea ? highlightedArea === item.name ? 1 : 0.1 : 1,
      isAnimationActive: false,
      ...typeof radarProps === "function" ? radarProps(item) : radarProps
    },
    index
  ));
  return (0, import_jsx_runtime11.jsx)(Box, { ref, ...getStyles("root"), ...others, children: (0, import_jsx_runtime11.jsx)(ResponsiveContainer, { ...getStyles("container"), children: (0, import_jsx_runtime11.jsxs)(RadarChart, { data, ...radarChartProps, children: [
    withPolarGrid && (0, import_jsx_runtime11.jsx)(PolarGrid, { stroke: "var(--chart-grid-color)", ...polarGridProps }),
    withPolarAngleAxis && (0, import_jsx_runtime11.jsx)(PolarAngleAxis, { dataKey, ...polarAngleAxisProps }),
    withPolarRadiusAxis && (0, import_jsx_runtime11.jsx)(PolarRadiusAxis, { stroke: "var(--chart-grid-color)", ...polarRadiusAxisProps }),
    radars,
    withLegend && (0, import_jsx_runtime11.jsx)(
      Legend,
      {
        verticalAlign: "bottom",
        content: (payload) => (0, import_jsx_runtime11.jsx)(
          ChartLegend,
          {
            payload: payload.payload,
            onHighlight: setHighlightedArea,
            legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "bottom",
            classNames: resolvedClassNames,
            styles: resolvedStyles,
            series,
            centered: true
          }
        ),
        ...legendProps
      }
    ),
    children
  ] }) }) });
});
RadarChart2.displayName = "@mantine/charts/RadarChart";
RadarChart2.classes = classes7;

// node_modules/@mantine/charts/esm/ScatterChart/ScatterChart.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
function getAxis(key, dataKey) {
  return key === dataKey.x ? "x" : "y";
}
var defaultProps10 = {
  withXAxis: true,
  withYAxis: true,
  withTooltip: true,
  tooltipAnimationDuration: 0,
  tickLine: "y",
  strokeDasharray: "5 5",
  gridAxis: "x"
};
var varsResolver8 = createVarsResolver((theme, { textColor, gridColor }) => ({
  root: {
    "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
    "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0
  }
}));
var ScatterChart2 = factory((_props, ref) => {
  const props = useProps("ScatterChart", defaultProps10, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    referenceLines,
    dir,
    withLegend,
    withTooltip,
    withXAxis,
    withYAxis,
    xAxisProps,
    yAxisProps,
    orientation,
    scatterChartProps,
    legendProps,
    data,
    gridAxis,
    tickLine,
    strokeDasharray,
    gridProps,
    tooltipAnimationDuration,
    tooltipProps,
    children,
    onMouseLeave,
    dataKey,
    textColor,
    gridColor,
    xAxisLabel,
    yAxisLabel,
    unit,
    labels,
    valueFormatter,
    scatterProps,
    ...others
  } = props;
  const getFormatter = (axis) => typeof valueFormatter === "function" ? valueFormatter : valueFormatter == null ? void 0 : valueFormatter[axis];
  const xFormatter = getFormatter("x");
  const yFormatter = getFormatter("y");
  const theme = useMantineTheme();
  const mappedData = data.map((item) => ({
    ...item,
    data: item.data.map((point) => ({ ...point, name: item.name }))
  }));
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const getStyles = useStyles({
    name: "ScatterChart",
    classes: classes3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver8
  });
  const withXTickLine = gridAxis !== "none" && (tickLine === "x" || tickLine === "xy");
  const withYTickLine = gridAxis !== "none" && (tickLine === "y" || tickLine === "xy");
  const [highlightedArea, setHighlightedArea] = (0, import_react6.useState)(null);
  const shouldHighlight = highlightedArea !== null;
  const handleMouseLeave = (event) => {
    setHighlightedArea(null);
    onMouseLeave == null ? void 0 : onMouseLeave(event);
  };
  const referenceLinesItems = referenceLines == null ? void 0 : referenceLines.map((line, index) => {
    const color = getThemeColor(line.color, theme);
    return (0, import_jsx_runtime12.jsx)(
      ReferenceLine,
      {
        stroke: line.color ? color : "var(--chart-grid-color)",
        strokeWidth: 1,
        ...line,
        label: {
          value: line.label,
          fill: line.color ? color : "currentColor",
          fontSize: 12,
          position: line.labelPosition ?? "insideBottomLeft"
        },
        ...getStyles("referenceLine")
      },
      index
    );
  });
  const scatters = mappedData.map((item, index) => {
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    return (0, import_jsx_runtime12.jsx)(
      Scatter,
      {
        data: item.data,
        fill: getThemeColor(item.color, theme),
        isAnimationActive: false,
        fillOpacity: dimmed ? 0.1 : 1,
        ...scatterProps
      },
      index
    );
  });
  return (0, import_jsx_runtime12.jsx)(
    Box,
    {
      ref,
      ...getStyles("root"),
      onMouseLeave: handleMouseLeave,
      dir: dir || "ltr",
      ...others,
      children: (0, import_jsx_runtime12.jsx)(ResponsiveContainer, { ...getStyles("container"), children: (0, import_jsx_runtime12.jsxs)(
        ScatterChart,
        {
          margin: {
            bottom: xAxisLabel ? 30 : void 0,
            left: yAxisLabel ? 10 : void 0,
            right: yAxisLabel ? 5 : void 0
          },
          ...scatterChartProps,
          children: [
            (0, import_jsx_runtime12.jsx)(
              CartesianGrid,
              {
                strokeDasharray,
                vertical: gridAxis === "y" || gridAxis === "xy",
                horizontal: gridAxis === "x" || gridAxis === "xy",
                ...getStyles("grid"),
                ...gridProps
              }
            ),
            (0, import_jsx_runtime12.jsxs)(
              XAxis,
              {
                type: "number",
                hide: !withXAxis,
                dataKey: dataKey.x,
                tick: { transform: "translate(0, 10)", fontSize: 12, fill: "currentColor" },
                stroke: "",
                interval: "preserveStartEnd",
                tickLine: withXTickLine ? { stroke: "currentColor" } : false,
                minTickGap: 5,
                unit: unit == null ? void 0 : unit.x,
                tickFormatter: xFormatter,
                ...getStyles("axis"),
                ...xAxisProps,
                children: [
                  xAxisLabel && (0, import_jsx_runtime12.jsx)(Label, { position: "insideBottom", offset: -20, fontSize: 12, ...getStyles("axisLabel"), children: xAxisLabel }),
                  xAxisProps == null ? void 0 : xAxisProps.children
                ]
              }
            ),
            (0, import_jsx_runtime12.jsxs)(
              YAxis,
              {
                type: "number",
                hide: !withYAxis,
                axisLine: false,
                dataKey: dataKey.y,
                tickLine: withYTickLine ? { stroke: "currentColor" } : false,
                tick: { transform: "translate(-10, 0)", fontSize: 12, fill: "currentColor" },
                allowDecimals: true,
                unit: unit == null ? void 0 : unit.y,
                tickFormatter: yFormatter,
                ...getStyles("axis"),
                ...yAxisProps,
                children: [
                  yAxisLabel && (0, import_jsx_runtime12.jsx)(
                    Label,
                    {
                      position: "insideLeft",
                      angle: -90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: yAxisLabel
                    }
                  ),
                  yAxisProps == null ? void 0 : yAxisProps.children
                ]
              }
            ),
            withTooltip && (0, import_jsx_runtime12.jsx)(
              Tooltip,
              {
                animationDuration: tooltipAnimationDuration,
                isAnimationActive: tooltipAnimationDuration !== 0,
                position: { y: 0 },
                cursor: {
                  stroke: "var(--chart-grid-color)",
                  strokeWidth: 1,
                  strokeDasharray
                },
                content: ({ label, payload }) => (0, import_jsx_runtime12.jsx)(
                  ChartTooltip,
                  {
                    type: "scatter",
                    label,
                    payload: labels ? payload == null ? void 0 : payload.map((item) => {
                      var _a;
                      return {
                        ...item,
                        name: labels[getAxis(item.name, dataKey)] || item.name,
                        value: ((_a = getFormatter(getAxis(item.name, dataKey))) == null ? void 0 : _a(item.value)) ?? item.value
                      };
                    }) : payload == null ? void 0 : payload.map((item) => {
                      var _a;
                      return {
                        ...item,
                        value: ((_a = getFormatter(getAxis(item.name, dataKey))) == null ? void 0 : _a(item.value)) ?? item.value
                      };
                    }),
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series: data
                  }
                ),
                ...tooltipProps
              }
            ),
            withLegend && (0, import_jsx_runtime12.jsx)(
              Legend,
              {
                verticalAlign: "top",
                content: (payload) => {
                  var _a;
                  return (0, import_jsx_runtime12.jsx)(
                    ChartLegend,
                    {
                      payload: (_a = payload.payload) == null ? void 0 : _a.map((item, index) => ({
                        ...item,
                        dataKey: data[index].name
                      })),
                      onHighlight: setHighlightedArea,
                      legendPosition: (legendProps == null ? void 0 : legendProps.verticalAlign) || "top",
                      classNames: resolvedClassNames,
                      styles: resolvedStyles,
                      series: data
                    }
                  );
                },
                height: 44,
                ...legendProps
              }
            ),
            referenceLinesItems,
            scatters
          ]
        }
      ) })
    }
  );
});
ScatterChart2.displayName = "@mantine/charts/ScatterChart";
ScatterChart2.classes = classes3;

// node_modules/@mantine/charts/esm/BubbleChart/BubbleChart.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
function getDomain(data, key) {
  const values = data.map((item) => item[key]);
  return [Math.min(...values), Math.max(...values)];
}
function BubbleChartTooltip({
  active,
  payload,
  getStyles,
  dataKey,
  valueFormatter
}) {
  if (active && payload && payload.length) {
    const data = payload[0] && payload[0].payload;
    return (0, import_jsx_runtime13.jsx)("div", { ...getStyles("tooltip"), children: (0, import_jsx_runtime13.jsxs)(Group, { justify: "space-between", children: [
      (0, import_jsx_runtime13.jsx)(Text, { fz: "sm", children: data[dataKey.x] }),
      (0, import_jsx_runtime13.jsx)(Text, { fz: "sm", children: valueFormatter ? valueFormatter(data[dataKey.z]) : data[dataKey.z] })
    ] }) });
  }
  return null;
}
var defaultProps11 = {
  color: "blue.6",
  withTooltip: true
};
var varsResolver9 = createVarsResolver((theme, { textColor, gridColor }) => ({
  root: {
    "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
    "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0
  }
}));
var BubbleChart = factory((_props, ref) => {
  const props = useProps("BubbleChart", defaultProps11, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    data,
    xAxisProps,
    yAxisProps,
    zAxisProps,
    tooltipProps,
    scatterProps,
    color,
    label,
    withTooltip,
    dataKey,
    range,
    valueFormatter,
    ...others
  } = props;
  const theme = useMantineTheme();
  const getStyles = useStyles({
    name: "BubbleChart",
    classes: classes3,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver: varsResolver9
  });
  return (0, import_jsx_runtime13.jsx)(Box, { ref, ...getStyles("root"), ...others, children: (0, import_jsx_runtime13.jsx)(ResponsiveContainer, { children: (0, import_jsx_runtime13.jsxs)(ScatterChart, { children: [
    (0, import_jsx_runtime13.jsx)(
      XAxis,
      {
        type: "category",
        dataKey: dataKey.x,
        interval: 0,
        tick: { fontSize: 12, fill: "currentColor" },
        tickLine: { transform: "translate(0, -6)", stroke: "currentColor" },
        stroke: "currentColor",
        ...getStyles("axis"),
        ...xAxisProps
      }
    ),
    (0, import_jsx_runtime13.jsx)(
      YAxis,
      {
        type: "number",
        dataKey: dataKey.y,
        height: 10,
        width: label ? void 0 : 0,
        tick: false,
        tickLine: false,
        axisLine: false,
        label: { value: label, position: "insideRight", fontSize: 12, fill: "currentColor" },
        ...getStyles("axis"),
        ...yAxisProps
      }
    ),
    (0, import_jsx_runtime13.jsx)(
      ZAxis,
      {
        type: "number",
        dataKey: dataKey.z,
        domain: getDomain(data, dataKey.z),
        range,
        ...zAxisProps
      }
    ),
    withTooltip && (0, import_jsx_runtime13.jsx)(
      Tooltip,
      {
        animationDuration: 100,
        isAnimationActive: false,
        cursor: { stroke: "var(--chart-grid-color)", strokeWidth: 1, strokeDasharray: "3 3" },
        content: (payload) => (0, import_jsx_runtime13.jsx)(
          BubbleChartTooltip,
          {
            dataKey,
            active: payload.active,
            payload: payload.payload,
            getStyles,
            valueFormatter
          }
        ),
        ...tooltipProps
      }
    ),
    (0, import_jsx_runtime13.jsx)(
      Scatter,
      {
        data,
        fill: getThemeColor(color, theme),
        isAnimationActive: false,
        ...scatterProps
      }
    )
  ] }) }) });
});
BubbleChart.displayName = "@mantine/charts/BubbleChart";
BubbleChart.classes = classes3;
export {
  AreaChart2 as AreaChart,
  AreaGradient,
  BarChart2 as BarChart,
  BubbleChart,
  ChartLegend,
  ChartTooltip,
  DonutChart,
  LineChart2 as LineChart,
  PieChart2 as PieChart,
  RadarChart2 as RadarChart,
  ScatterChart2 as ScatterChart,
  Sparkline,
  getFilteredChartLegendPayload,
  getFilteredChartTooltipPayload,
  getSplitOffset
};
//# sourceMappingURL=@mantine_charts.js.map
